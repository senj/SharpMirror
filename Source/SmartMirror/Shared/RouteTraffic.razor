@using SmartMirror.Data.Routes
@inject RouteService RouteService

@if (!Show)
{
    return;
}

<div class="container-fluid card-1">
    <div class="row">
        <div class="col-12">
            <p class="box-heading">ROUTES AND TRAFFIC</p>
        </div>
    </div>
    <div class="row">
        <div class="col-12">
            @if (RouteResponse == null || !RouteResponse.routes.Any())
            {
                <p>No route requested.</p>
            }
            else
            {
                var summary = RouteResponse.routes.FirstOrDefault().summary;
                <p>@SourceGeoResponse.results.FirstOrDefault().address.freeformAddress - @DestinationGeoResponse.results.FirstOrDefault().address.freeformAddress</p>
                <br />
                if (summary.departureTime.Date != summary.arrivalTime.Date)
                {
                    <p>
                        @summary.departureTime.ToString("dd.MM.") <b>@summary.departureTime.ToString("HH:mm")</b>
                        - @summary.arrivalTime.ToString("dd.MM.") <b>@summary.arrivalTime.ToString("HH:mm")</b>
                    </p>
                }
                else
                {
                    <p>
                        @summary.departureTime.ToString("dd.MM.") <b>@summary.departureTime.ToString("HH:mm")</b>
                        - <b>@summary.arrivalTime.ToString("HH:mm")</b>
                    </p>
                }

                <p>@(summary.lengthInMeters / 1000) km</p>

                double durationInHours = Math.Floor(summary.liveTrafficIncidentsTravelTimeInSeconds / 3600d);
                double durationInMinutes = summary.liveTrafficIncidentsTravelTimeInSeconds / 60 % 60;
                double delayInHours = Math.Floor(summary.trafficDelayInSeconds / 3600d);
                double delayInMinutes = summary.trafficDelayInSeconds / 60 % 60;
                string trafficString = string.Empty;

                if (durationInHours != 0)
                {
                    trafficString = $"{durationInHours}h";
                }

                if (durationInMinutes != 0)
                {
                    trafficString += $" {durationInMinutes}min";
                }

                if (delayInHours != 0 && delayInMinutes != 0)
                {
                    trafficString += $" ({delayInHours}h {delayInMinutes}min delay)";
                }
                else if (delayInMinutes != 0)
                {
                    trafficString += $" ({delayInMinutes}min delay)";
                }

                <p>@trafficString</p>
            }
            <br />
            <p><em>Route|Strecke|Verbindung {source (one word)} {destination (one word)}</em></p>
            <p><em>Weg|Strecke zur Arbeit Lukas|Alisa</em></p>            
        </div>
    </div>
</div>
<br />

@code {
    [Parameter]
    public bool Show { get; set; }

    public RouteResponse RouteResponse { get; set; }
    public GeosearchResponse SourceGeoResponse { get; set; }
    public GeosearchResponse DestinationGeoResponse { get; set; }

    [CascadingParameter(Name = "LayoutRazor")] protected Layout Layout { get; set; }

    protected override async Task OnInitializedAsync()
    {
        Layout.AddToParent<RouteTraffic>(this);
        base.OnInitializedAsync();
    }

    public async Task<RouteResponse> SetRouteAsync(string source, string destination)
    {
        (bool sourceFound, bool destinationFound) = SetKnownLocations(source.ToLower(), destination.ToLower());
        if (!sourceFound)
        {
            SourceGeoResponse = await RouteService.SearchAsync(source);
        }

        if (!destinationFound)
        {
            DestinationGeoResponse = await RouteService.SearchAsync(destination);
        }

        if (SourceGeoResponse?.results.Any() != true || DestinationGeoResponse?.results?.Any() != true)
        {
            return new RouteResponse();
        }

        RouteResponse = await RouteService.GetRouteAsync(new RouteRequest
        {
            Departure = new Geopoint
            {
                Latitude = SourceGeoResponse.results.FirstOrDefault().position.lat,
                Longitude = SourceGeoResponse.results.FirstOrDefault().position.lon
            },
            Destination = new Geopoint
            {
                Latitude = DestinationGeoResponse.results.FirstOrDefault().position.lat,
                Longitude = DestinationGeoResponse.results.FirstOrDefault().position.lon
            }
        });

        StateHasChanged();

        return RouteResponse;
    }

    private (bool, bool) SetKnownLocations(string source, string destination)
    {
        bool sourceFound = false, destinationFound = false;
        Position sourcePosition = new Position();
        Position destinationPosition = new Position();
     
        if (source == "zuhause lukas")
        {
            sourcePosition = new Position { lat = 48.663491f, lon = 9.381447f };
            sourceFound = true;
        }

        if (destination == "arbeit lukas")
        {
            destinationPosition = new Position { lat = 48.671431f, lon = 9.363197f };
            destinationFound = true;
        }

        SourceGeoResponse = new GeosearchResponse
        {
            results = new Result[]
        {
                    new Result
                    {
                        position = sourcePosition,
                        address = new Address { freeformAddress = "Zuhause" }
                    }
            }
        };

        DestinationGeoResponse = new GeosearchResponse
        {
            results = new Result[]
            {
                    new Result
                    {
                        position = destinationPosition,
                        address = new Address { freeformAddress = "Arbeit" }
                    }
                }
        };

        return (sourceFound, destinationFound);
    }
}
